Design considerations
=====================

# Goal

Load the representation of a git,svn, csv, tarball, et al. repository in software
heritage's backend.

# Nomenclature

cf. swh-sql/swh.sql comments
-> FIXME: find a means to compute docs from sql

# Scenario

In the following, we will describe with different granularities what will
happen between 1 worker and the backend api.

## 1

A worker parses a repository.
It sends the parsing result to the backend in muliple requests/responses.
The worker sends list of sha1s (git sha1s) encountered.
The server responds with an unknowns sha1s list.
The worker sends those sha1s and their associated data to the server.
The server store what it receives.

## 2

From the following section, `checksums` means the git sha1s, the sha1 and sha256
of the object's content.

01. Worker parses local repository and build a memory model of the repository.

02. Worker sends repository's contents checksums to the backend for it to filter.
03. Backend replies with unknown contents sha1s.
04. Worker sends all `content` data through 1 (or more) request(s).
05. Backend stores them and finish the transaction(s).

06. Worker sends repository's directories' checksums to the backend for it to filter.
07. Backend replies with unknown directory sha1s.
08. Worker sends all `directory`s' data through 1 (or more) request(s).
09. Backend stores them and finish the transaction(s).

10. Worker sends repository's revisions' checksums to the backend.
11. Backend replies with unknown revisions' sha1s.
12. Worker sends the `revision`s' data through 1 (or more) request(s).
13. Backend stores them and finish the transaction(s).
14. Worker is done.

## 3

1. Worker parses repository and builds a data memory model.
The data memory model has a structure identifying each possible type of object:
- list of checksums
- map indexed by git sha1, object representation.
Type of object ; content, directory, revision, release, occurence is kept.

2. Worker sends in the api backend's protocol the sha1s.

3. Api Backend receives the list of sha1s, filters out
unknown sha1s and replies to the worker.

4. Worker receives the list of unknown sha1s.
Builds the `content`'s structure:
- git's sha1 (when parsing git repository)
- sha1 content (as per content's sha1)
- sha256 content
- content's size
- content

And sends it to the api's backend.

5. Backend receives the data and:
- computes from the `content` the checksums (sha1, sha256).
- checks the checksums match the client's data
- Stores the content on the file storage
- Persist in the db the received data
If any errors is detected during the process (checksum do not match, writing
error, ...), the db transaction is rollbacked and a failure is sent to the
client.
Otherwise, the db transaction is committed and a success is sent back  to the
client.

*Note* Optimization possible: slice in multiple queries.

6. Worker receives the result from the api.
If failure, worker stops. The task is done.
Otherwise, the worker continues by building the list of `directory` structure.

for each directory:
- sha1
- directory's content
- list of directory entries:
  - name     : relative path to parent entry or root
  - sha1     : pointer to the object this directory points to
  - type     : whether entry is a file or a dir
  - perms    : unix-like permissions
  - atime    : time of last access
  - mtime    : time of last modification
  - ctime    : time of last status change
  - directory: parent directory sha1

And sends it to the api's backend.

*Note* Optimization possible: slice in multiple queries.

7. Api backend receives the data.
Persists the directory's content on the file storage.
Persist the directory and directory entries on the db's side in respect to the
previous directories and contents stored.

If any error is raised, the transaction is rollbacked and an error is sent back
to the client (worker).
Otherwise, the transaction is committed and the success is sent back to the
client.

8. Worker receives the result from the api.
If failure, worker stops. The task is done.
Otherwise, the worker continues by building the list of `revision` structure.

A list of revisions, for each revision:
- sha1, the revision's sha1
- revision's parent sha1s, the list of revision parents
- content, the revision's content
- revision's date
- directory id the revision points to
- message, the revision's message
- author
- committer

And sends it to the api's backend.

*Note* Optimization possible: slice in multiple queries.

9. Api backend receives data.
Persists the revisions' content on the file storage.
Persist the directory and directory entries on the db's side in respect to the
previous directories and contents stored.

If any error is raised, the transaction is rollbacked and an error is sent back
to the client (worker).
Otherwise, the transaction is committed and the success is sent back to the
client.

10. Worker receives the result and stops anyway.
The task is done.
